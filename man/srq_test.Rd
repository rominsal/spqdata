% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/srq_test.R
\name{srq_test}
\alias{srq_test}
\title{A function to calculate the spatial runs test}
\usage{
SR_test(fx = fx, listw = listw, alternative="less")
}
\arguments{
\item{fx}{vector de observaciones Factor}

\item{listw}{Una lista de los k vecinos más próximos o una matrix W de distancias. Para calcular el numero
de rachas en cada m-entorno debe establecerse un orden de los vecinos de más próximo a más lejano.}

\item{alternative}{a character string specifying the alternative hypothesis, must be one
of "two.sided", "greater" or "less" (default).}

\item{nsim}{Number of permutations to optain confidence intervals. Default value is NULL to dont get CI of number of runs and local.}
}
\value{
decir que devuelve
  \tabular{ll}{
    \code{SR} \tab numero total de rachas \cr
    \code{dnr} \tab distribución numero de rachas \cr
    \code{SRQ} \tab Test de homogeneidad. Negative sign indicates global homogeneity \cr
    \code{p.valueSRQ} \tab pvalor de SRglobal \cr
    \code{p.valueSRQB} \tab pvalor de SRglobal por boots\cr
    \code{SRGP} \tab vector con los nsim valores de SRGlobal por remuestreo permutacional\cr
    \code{SRQlocal} \tab una matriz donde cada fila muestra el valor del estadístico... \cr
    \code{SRLP} \tab matrix de orden n x nsim con los valores de SRLocal por remuestreo permutacional\cr
    \code{xxx} \tab no se \cr
    }
}
\description{
This function calculates the runs test for spatial independence
}
\details{
La matrix listw puede ser de tres tipos:
tabular{ll}{
    \code{knn} \tab Criterio del vecino más próximo \cr
    \code{nb} \tab Si ontenemos los vecionos  \cr
    \code{matrix} \tab Una matriz basada en inversa de la distancia. Bebe contener ceros.\cr
    }
Aquí Antonio escribe una linda historia
}
\examples{

# SRQ test based on knn
N <- 100
cx <- runif(N)
cy <- runif(N)
x <- cbind(cx,cy)
listw <- knearneigh(cbind(cx,cy), k=4)
p <- c(1/6,3/6,2/6)
rho = 0.5
QY <- dgp_spq(x = x, p = p, listw = listw, rho = rho)
srq <- srq_test(fx = QY, listw = listw)
srq$SRglobal

# Fastfood example
data("FastFood")
x <- cbind(FastFood.sf$Lon,FastFood.sf$Lat)
listw <- spdep::knearneigh(x, k=4)
srq <- srq_test(fx=FastFood.sf$Type,listw)
srq$SRglobal

# With a sf object (poligons)
library(sf)
fname <- system.file("shape/nc.shp", package="sf")
nc <- st_read(fname)
listw <- spdep::poly2nb(as(nc,"Spatial"), queen = FALSE)
# Hace falta ordenar por DISTANCIA (menor a mayor) los elementos del objeto nb
listw <- nb2nb_order(listw=listw, sf = nc)
p <- c(1/6,3/6,2/6)
rho = 0.5
co <- sf::st_coordinates(st_centroid(nc))
nc$Q <- dgp_spq(x = co, p = p, listw = listw, rho = rho)
# plot(nc["Q"])
srq <- srq_test(fx = nc$Q, listw = listw, nsim=399)
c(srq$SRglobal,srq$p.valueSRQ,srq$p.valueSRQB)

# SRQ test based on inverse distance
data("FastFood")
x <- cbind(FastFood.sf$Lon,FastFood.sf$Lat)
dis <- distm(x, fun=distGeo)
M1 <- matrix(x[,1],ncol = dim(x)[1],nrow=dim(x)[1])
M2 <- matrix(x[,2],ncol = dim(x)[1],nrow=dim(x)[1])
dis <- sqrt((M1-t(M1))^2+(M2-t(M2))^2)
dis <- (dis < quantile(dis,.1))*1
diag(dis) <- 0



co <- sf::st_coordinates(st_centroid(nc))
listw <- knearneigh(co[,1:2], k=4)
p <- c(1/6,3/6,2/6)
rho = 0.5
nc$Q <- dgp_spq(x = co, p = p, listw = listw, rho = rho)
plot(nc["Q"])


}
\seealso{
\code{\link{dgp_spq}}, \code{\link{m_surr_no}}
}
\author{
\tabular{ll}{
  Fernando López  \tab \email{fernando.lopez@upct.es} \cr
  Román Mínguez  \tab \email{roman.minguez@uclm.es} \cr
  Antonio  \tab \email{paez@gmail.com} \cr
  Manolo  \tab \email{manuel.ruiz@upct.es} \cr
  }
  @references
  \itemize{
    \item Ruiz, M., López, F., and Páez, A. (2010).
    A test for global and local homogeneity of categorical data based on spatial runs.
      \emph{Geographical Analysis}.
  }
}
\keyword{association,}
\keyword{qualitative}
\keyword{runs}
\keyword{spatial}
\keyword{test}
\keyword{variable,}
